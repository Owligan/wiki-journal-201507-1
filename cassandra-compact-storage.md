# 理解 Cassandra 压缩储存的作用  
## 介绍  
在 Librato，我们对时间序列的储存主要是应用了我们一直在研发的自定义架构所建立的 Apache Cassandra。关于它我们之前已经写到并呈现过几次。在 Cassandra 上我们既存储真实的时间序列也存储历史汇总时间序列。Cassandra 存储节点在我们的基础设施中占有最大的足迹因而这些节点驱动着我们的成本开支，所以我们一直在寻找方式来改进我们数据的效率。  
  
作为我们正在进行的效率改进和后台功能研发的部分，我们最近花时间重新评估了我们的存储架构。自 Cassandra 0.8.x 版本的早期以来，我们的架构一直被建立在 Thrift APIs 的内容之上，并且无论何时当我们竖起一个新环路，我们使用‘节点工具’命令来移动它。我们一直都在紧密的跟随 CQL 的发展并且已经将我们的读取路径的部分在 2.0.x 版本中移动到了新的本地接口。甚至，我们想要更进一步关注使用本地 CQL 接口完全构造我们的架构转移（创建 CQL 表，或者他们所称的“列族”）。  
  
## CQL 表存储选项  
  
先前当我们关注 CQL 表结构时困住我们的事情之一是涉及到一个 COMPACT STORAGE 选项--我将停止呼喊并且从这之后把它称作为压缩存储。其定义文档如下：  
  
“…主要将对 CQL3 之前创建的定义的反向兼容性为目标…在硬盘上提供一个更压缩紧凑一些的数据分布，但这样是以减小适应新和拓展性为代价的…由于以上原因是不推荐向后兼容性之外使用的。”  
  
在 CQL 之前当 Thrift 接口是唯一的 API 时，所有的表都是以压缩存储的方式建立的。和文档状态一样，它是一个除了向后兼容性外别无它用的遗留选项。  
  
在我们的调研大约进行到这个时候我们偶然发现了某团队研究解析的一篇博客文章。主要是关于他们对 CQL 表的经验认识。这是一篇很棒的文章，我十分推荐它。文章有一段的标题是“我们没有使用 COMPACT STORAGE…你敢相信下面发生了什么吗”。它记录了使用压缩存储的他们自己的调研。在这篇文章中，他们提及了当没有对表使用压缩存储时他们看到一个大 30 倍的存储空间容量。如果知道我们所处理的数据库的容量大小，这种类型的增大是不可忽视的。  
  
## CQL 数据分布  
  
那么让我们研究一下一个 CQL 表的数据分布是什么样的。我们将以一个简化过的例子开始，它来自用 Cassandra 建立一项音乐服务的教程指南。我们已经用一个<id，song_id>的指针把表减少到只有一个 id，音乐 id 和歌曲名称。  

